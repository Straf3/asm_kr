; ------- Код для резидентной части ------
; ********** Новый обработчик мультиплексного прерывания 2Fh **********
; *           Используется для управления программой извне. 	*
; * Вход: АН=0CDh - перехватываемая функция. 			*
; *       AL: запрашиваемое действие				*
; *  AL=00: проверка на установленность. Выход: AL=01: загружена 	*
; *  AL=01: выгрузить программу. Выход: AL=00: успех, AL=0E: неудача	*
; *********************************************************************
 New_2Fh proc near
  cmp AH, 0CDh  		; Наша функция?
  jne CallStandart 		; Нет-вызываем стандартный обработчик
  cmp AL, 00h		; проверка на установленность
  je Loaded
  cmp AL, 01h		; выгрузить программу
  je UnLoad
  iret		 	; ###
 CallStandart:
 ; Используем jmp, чтобы не связываться со стеком. В этом случае после
 ; отработки системного обработчика в наш управление не возвращается.
  jmp CS:Old_2Fh		; вызываем стандартный обработчик
 Loaded:
  mov AL, 01h		; да, прога уже установлена
  iret
 UnLoad:			; выгрузить программу
  push DS ES BX CX DX	; сохраним используемые регистры
  mov AL, 0Eh		; пишем код ошибки при выгрузке
  call CheckIfLast		; проверяем, можно ли выгружать
  cmp AL, 0Eh		; нельзя-на выход
  je Finish_New_2Fh		
 ; восстанавливаем перехваченные векторы
 ; восстанавливаем 09h
  mov AX, 2509h		; 25-установка вектора, 09-номер
  lds DX, CS:Old_09h	; DS:=HIBYTE(Old_09h), DX:=LOBYTE(Old_09h)
  int 21h
 ; восстанавливаем 2Fh
  mov AX, 252Fh		; 25-установка вектора, 2F-номер
  lds DX, CS:Old_2Fh	; DS:=HIBYTE(Old_2Fh), DX:=LOBYTE(Old_2Fh)
  int 21h
 ; Получим из PSP адрес собственного окружения и выгрузим его
  mov ES,CS:2Ch
  mov AH, 49h		; функция освобождения памяти
  int 21h
 ; а теперь выгрузим саму программу
  push CS			
  pop ES			; ES:=CS-указывает на PSP
  mov AH, 49h		; функция освобождения памяти
  int 21h			
 Finish_New_2Fh:  
  pop DX CX BX ES DS 	; восстанавливаем  используемые регистры
  iret
 New_2Fh endp

; *********** Проверка, является ли наш вектор 09h последним ***********
; *         Только в этом случае возможна корректная выгрузка     	 *
; *  Т.к. код ошибки уже записан в AL, при невозможности выгрузки надо *
; *  всего лишь пойти на выход. В противном случае-записать в AL ноль  *
; **********************************************************************
CheckIfLast proc
; получим в ES:BX адрес последнего вектора
 push AX			; сохраняем
 mov AH, 35h
 mov AL, 09h
 int 21h
 pop AX
 cmp BX, offset New_09h
 jne FinCheck
 mov CX,ES
 mov BX,CS
 cmp CX,BX
 jne FinCheck
 mov AL,00
FinCheck:
 ret
CheckIfLast endp

; *********** Новый обработчик прерывания от клавиатуры 09h ***********
; *             Используется для активации замены шрифта. 	 	*
; *********************************************************************
 New_09h proc near
  cli
  pushf
  ; А здесь используем call, так как сначала вызываем системный
  ; обработчик, а потом надо перейти в наш 
  call CS:Old_09h
  push AX BX CX ES
  ; получим символ из буфера
  mov AX, 40h
  mov ES,AX		; по адресу 40h находятся данные БИОС
  mov BX, ES:1ah		; адрес очередного символа
  mov AX, ES:[BX]		; в АХ - скан-код нажатой клавиши
  cmp AX, F5			; Была нажата F5?
  je TwasF5				; Выставим флаг в конце и офф
  cmp AX, F6			; наша ?
  je SwapSection
  jne Finish_New_09h	; нет-на выход
  
TwasF5:
  cmp flagf5, 0
  jne FlagOne
  mov flagf5, 1
  jmp Finish_New_09h
	FlagOne:
		mov flagf5, 0
		jmp Finish_New_09h
  
SwapSection:
  cmp flagf5, 1
  jne Finish_New_09h
  call SwapChars		; да-заменяем шрифт
  
Finish_New_09h:
  pop ES CX BX AX
  sti
  iret
 New_09h endp

; ******* Процедура замены шрифта в зависимости от значения flag *******
SwapChars proc near
 pusha
 push ES			; сохраняем регистры
 
 ;mov AX,0B800h	; адрес текстовой видеопамяти
 ;mov ES, AX
 ;mov Ah, flag
 ;mov Al, 0fh
 ;mov ES:1,ax	; 0F- белый на чёрном фоне, 07-ASCII код символа

 cmp flag,1
 je LoadNew
 cmp flag,2
 je LoadOld
 ; 1-й раз - сохраняем старый шрифт, потом переходим на LoadNew
 push DS
 mov AX,1130h
 mov BH, 01h 		; Получаем адрес старого шрифта
 int 10h
 ; ES:BP - адрес старого шрифта
 ; Для movsb надо: DS:SI-адрес источника
 push DS ES		; \ меняем содержимое
 pop DS ES		; / DS и ES местами.
 mov SI,BP
 add SI,'А'*16		; начальный символ
 mov DI,offset buffchars
 ; ES:DI-адрес приёмника
 cld			; DF:=0 (двигаемся вперёд)
 mov CX,16*5		; количество повторений
 rep movsb		; oldchar:=старый шрифт
 pop DS			; восстанавливаем DS
LoadNew: 
 ; рисуем символ в верхнем левом углу экрана
 mov AX,0B800h	; адрес текстовой видеопамяти
 mov ES, AX
 mov ES:0,0F07h	; 0F- белый на чёрном фоне, 07-ASCII код символа

 mov AX, CS		; ES:=CS
 mov ES, AX
 
 mov AX, 1110h		; Загрузка и активация шрифта
 mov BH,16		; Высота символа
 mov BL,0			; Блок знакогенератора
 mov CX,5			; Количество символов
 mov DX,'А'		; ASCII код символа А
 mov BP, offset newchar	; ES:BP - адрес нового шрифта
 int 10h
 mov flag,2	; Следующий раз надо будет загружать старый шрифт
 jmp Fin
 
LoadOld: 
 ; рисуем символ в верхнем левом углу экрана
 mov AX,0B800h	; адрес текстовой видеопамяти
 mov ES, AX
 mov ES:0,0F09h	; 0F- белый на чёрном фоне, 09-ASCII код символа

 mov AX, CS		; ES:=CS
 mov ES, AX
 
 mov AX, 1110h		; Загрузка и активация шрифта
 mov BH,16		; Высота символа
 mov BL,0			; Блок знакогенератора
 mov CX,5			; Количество символов
 mov DX,'А'		; ASCII код символа А
 mov BP, offset oldchars	; ES:BP - адрес нового шрифта
 int 10h
 mov flag,1	; Следующий раз надо будет загружать новый шрифт
 
Fin:
 pop ES
 popa			; восстанавливаем регистры
 ret			; возврат
SwapChars endp

; +++++++ Данные резидентной части +++++++
 Old_2Fh dd 0
 Old_09h dd 0
 F6	equ 4000h		; горячая клавиша
 F5	equ 3F00h
 flagf5 db 0	; 1/0=>F5 была/не была нажата
 flag db 0		; 0=>1-й запуск; 1=>грузить новый шрифт; 2=>старый                      
 buffchars db 80 dup(0)      	; буфер для старого шрифта
oldchars db 00000000b
        db 00000000b
        db 00000000b
        db 00010000b
        db 00111000b
        db 01101100b
        db 11000110b
        db 11000110b
        db 11000110b
        db 11111110b
        db 11000110b
        db 11000110b
        db 11000110b
        db 00000000b
        db 00000000b
        db 00000000b
	; ?
        db 00000000b    
        db 00000000b
        db 00000000b
        db 11111110b
        db 01100110b
        db 01100010b
        db 01111100b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 11111100b
        db 00000000b
        db 00000000b
        db 00000000b
	; В
        db 00000000b    
        db 00000000b
        db 00000000b
        db 11111100b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01111100b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 11111100b
        db 00000000b
        db 00000000b
        db 00000000b
	; ?
        db 00000000b    
        db 00000000b
        db 00000000b
        db 11111110b
        db 01100110b
        db 01100010b
        db 01100000b
        db 01100000b
        db 01100000b
        db 01100000b
        db 01100000b
        db 01100000b
        db 11110000b
        db 00000000b
        db 00000000b
        db 00000000b
	; Д
        db 00000000b    
        db 00000000b
        db 00000000b
        db 00011111b
        db 00110110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 11111111b
        db 11000011b
        db 00000000b
        db 00000000b
	; А
newchar db 00000000b	; новые начертания букв АБВГД
        db 00000000b
        db 00000000b
        db 00010000b
        db 00111000b
        db 01101100b
        db 11000110b
        db 11000110b
        db 11000110b
        db 11111110b
        db 11000110b
        db 11000110b
        db 11000110b
        db 00000000b
        db 11111111b
        db 00000000b
	; ?
        db 00000000b    
        db 00000000b
        db 00000000b
        db 11111110b
        db 01100110b
        db 01100010b
        db 01111100b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 11111100b
        db 00000000b
        db 11111111b
        db 00000000b
	; В
        db 00000000b    
        db 00000000b
        db 00000000b
        db 11111100b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01111100b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 11111100b
        db 00000000b
        db 11111111b
        db 00000000b
	; ?
        db 00000000b    
        db 00000000b
        db 00000000b
        db 11111110b
        db 01100110b
        db 01100010b
        db 01100000b
        db 01100000b
        db 01100000b
        db 01100000b
        db 01100000b
        db 01100000b
        db 11110000b
        db 00000000b
        db 11111111b
        db 00000000b
	; Д
        db 00000000b    
        db 00000000b
        db 00000000b
        db 00011111b
        db 00110110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 01100110b
        db 11111111b
        db 11000011b
        db 11111111b
        db 00000000b